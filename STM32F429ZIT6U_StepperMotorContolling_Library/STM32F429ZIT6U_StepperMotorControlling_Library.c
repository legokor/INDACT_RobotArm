/**
  ******************************************************************************
  * @file     lib.c
  * @author   Auto-generated by STM32CubeIDE
  * @version  V1.0
  * @date     04/03/2023 20:54:09
  * @brief    Default under dev library file.
  ******************************************************************************
*/

/* Includes ------------------------------------------------------------------*/
#include "stm32f4xx_hal.h"
#include "StepperMotorControll.h"
/** Functions ----------------------------------------------------------------*/
/*
 * Set manually the direction of a motor.
 * INPUTS:
 * @param (StepperMotor*) stepperMotors: pointer to array, that contains the motor's structs
 * @param (uint8_t) motor_id: ID of the motor, that you want to manipulate : MOTOR_R/FI/Z_ID
 * @param (uint8_t) direction: the direction define you want to set : MOTORDIR_POSITIVE/NEGATIVE/UNDEFINED
 *
 * OU
 * If allowedDir prohibits a direction, output value will be 1 and dir wont be overwritten.
 * OK: retval = 0; ERROR: retval = 1;
 */
uint8_t setMotorDir(StepperMotor *stepperMotors, uint8_t motor_id, uint8_t direction)
{
	uint8_t return_value;

	if(MOTORDIR_UNDEFINED == direction){
		stepperMotors[motor_id].dir = MOTORDIR_UNDEFINED;
		return_value = 0;
	}
	else if(MOTORDIR_POSITIVE == direction || MOTORDIR_NEGATIVE == direction){
		switch (stepperMotors[motor_id].allowedDir) {
			case MOTORALLOW_BOTHDIR: {
				stepperMotors[motor_id].dir = direction;
				return_value = 0;
				break;
			}
			case MOTORALLOW_POSDIR: {
				if(MOTORDIR_POSITIVE == direction){
					stepperMotors[motor_id].dir = MOTORDIR_POSITIVE;
					return_value = 0;
				}
				else return_value = 1;
				break;
			}
			case MOTORALLOW_NEGDIR: {
				if(MOTORDIR_NEGATIVE == direction){
					stepperMotors[motor_id].dir = MOTORDIR_NEGATIVE;
					return_value = 0;
				}
				else return_value = 1;
				break;
			}
			default: {
				return_value = 1;
				break;
			}
		}
	}
	else return_value = 1;

	HAL_GPIO_WritePin(stepperMotors[motor_id].dirPORT, stepperMotors[motor_id].dirPIN, stepperMotors[motor_id].dir);

	return return_value;
}


/*
 * Set all of the motors' direction to the given direction.
 *
 * Return value represents the errors:
 * Return value equals to zero. -> The function closed without error.
 * A 1 placed in the fourth position of return_value. -> the FI axis' direction has not been set correctly.
 * A 1 in the third position. -> The Z axis' direction has not been set correctly.
 * A 1 in the second position. -> The R axis' direction has not been set correctly.
 * For example the return value b0000 1010 means, that an error happened while setting FI and R axis' direction.
 */
uint8_t setAllMotorDir(StepperMotor *stepperMotors, uint8_t direction){
	uint8_t return_value;

	for(uint8_t idx = 0; idx < NUMBER_OF_MOTORS; idx++){
		return_value = setMotorDir(stepperMotors, idx, direction);
		return_value = return_value << 1;
	}

	return return_value;
}


/*
 * Set the motor directions according to the next position where the tool will go.
 *
 * Return value represents the errors:
 * Return value equals to zero. -> The function closed without error.
 * A 1 placed in the fourth position of return_value. -> the FI axis' direction has not been set correctly.
 * A 1 in the third position. -> The Z axis' direction has not been set correctly.
 * A 1 in the second position. -> The R axis' direction has not been set correctly.
 * For example the return value b0000 1010 means, that an error happened while setting FI and R axis' direction.
 */
uint8_t setAllMotorDirTowardsDesiredPos(StepperMotor *stepperMotors, ToolPosition curr_pos, ToolPosition next_pos)
{
	uint8_t return_value;

	int32_t differences[3];
	differences[0] = (int32_t)(next_pos.fi - curr_pos.fi);
	differences[1] = (int32_t)(next_pos.z - curr_pos.z);
	differences[2] = (int32_t)(next_pos.r - curr_pos.r);

	for(uint8_t idx = 0; idx < 3; idx++){
		if(0 == differences[idx]){
			return_value = setMotorDir(stepperMotors, idx, MOTORDIR_UNDEFINED);
		}
		else if(0 > differences[idx]){
			return_value = setMotorDir(stepperMotors, idx, MOTORDIR_NEGATIVE);
		}
		else{
			return_value = setMotorDir(stepperMotors, idx, MOTORDIR_POSITIVE);
		}

		return_value = return_value << 1;
	}
	return return_value;
}


/*
 * Sets the state of the motor to running and starts timer PWM with IT
 */
void motorON(StepperMotor *stepperMotors, uint8_t motor_id)
{
	HAL_TIM_PWM_Start_IT(stepperMotors[motor_id].TIM, stepperMotors[motor_id].TIM_CH);
	stepperMotors[motor_id].motorState = MOTORSTATE_RUNNING;
	return;
}


/*
 * Check out: startMotor
 */
void allMotorON(StepperMotor *stepperMotors)
{
	for (uint8_t idx = 0; idx < NUMBER_OF_MOTORS; idx++)
		motorON(stepperMotors, idx);
	return;
}


/*
 * Properly starting a motor
 * It checks for forbidden directions, sets the direction pin and the state variable in the stepperMotor struct.
 */
uint8_t startMotor(StepperMotor *stepperMotors, uint8_t motor_id, uint8_t direction){
	uint8_t return_value;

	uint8_t setdir_error = setMotorDir(stepperMotors, motor_id, direction);

	if(setdir_error){
		return_value = 1;
	}
	else{
		motorON(stepperMotors, motor_id);
		return_value = 0;
	}

	return return_value;
}


/*
 * Properly starting all of the motors.
 * It checks for forbidden directions, sets the direction pin and the state variable in the stepper motors.
 *
 * Return value represents the errors:
 * Return value equals to zero. -> The function closed without error.
 * A 1 placed in the fourth position of return_value. -> the FI axis' direction has not been set correctly.
 * A 1 in the third position. -> The Z axis' direction has not been set correctly.
 * A 1 in the second position. -> The R axis' direction has not been set correctly.
 * For example the return value b0000 1010 means, that an error happened while setting FI and R axis' direction.
 */
uint8_t startAllMotor(StepperMotor *stepperMotors, uint8_t direction){
	uint8_t return_value, start_error;

	for(uint8_t idx = 0; idx < NUMBER_OF_MOTORS; idx++){
		start_error = startMotor(stepperMotors, idx, direction);
		start_error = start_error << 1;
	}

	if(start_error){
		return_value = start_error;
	}
	else{
		return_value = 0;
	}

	return return_value;
}


/*
 * Stops timer PWM and sets the state of the motor to stopped.
 */
void stopMotor(StepperMotor *stepperMotors, uint8_t motor_id)
{
	HAL_TIM_PWM_Stop_IT(stepperMotors[motor_id].TIM, stepperMotors[motor_id].TIM_CH);
	stepperMotors[motor_id].motorState = MOTORSTATE_STOPPED;
	return;
}


/*
 * It brings the three motors to a stop.
 * Check out: stopMotor() function.
 */
void stopAllMotor(StepperMotor *stepperMotors)
{
	for (uint8_t idx = 0; idx < NUMBER_OF_MOTORS; idx++)
		if(MOTORSTATE_RUNNING == stepperMotors[idx].motorState)
			stopMotor(stepperMotors, idx);
	return;
}


/*
 * Controls a motor with two GPIO pin.
 * One pin drives the motor to positive direction, the other drives it to the opposite direction.
 */
uint8_t controlMotor_viaGPIO (GPIO_PinState* limit_switches, GPIO_TypeDef* pos_button_port, uint16_t pos_button_pin, GPIO_TypeDef* neg_button_port, uint16_t neg_button_pin, StepperMotor *stepperMotors, uint8_t motor_id)
{
	//stopped: return_value == 0, started: return_value == 1
	uint8_t return_value;

	GPIO_PinState pos_button = HAL_GPIO_ReadPin(pos_button_port, pos_button_pin);
	GPIO_PinState neg_button = HAL_GPIO_ReadPin(neg_button_port, neg_button_pin);

	if(pos_button && neg_button){
	  stopMotor(stepperMotors, motor_id);
	  return_value = 0;
	}
	else if(pos_button){
		if(!limit_switches[((motor_id+1)*2)-1]){
			startMotor(stepperMotors, motor_id, MOTORDIR_POSITIVE);
			return_value = 1;
		}
		else{
			stopMotor(stepperMotors, motor_id);
			return_value = 0;
		}
	}
	else if(neg_button){
		if(!limit_switches[(motor_id+1)*2]){
			startMotor(stepperMotors, motor_id, MOTORDIR_NEGATIVE);
			return_value = 1;
		}
		else{
			stopMotor(stepperMotors, motor_id);
			return_value = 0;
		}
	}
	else {
	  stopMotor(stepperMotors, motor_id);
	  return_value = 0;
	}
	return return_value;
}



/*
 * In a nutshell: RCR delays the timer IT.
 * The RC register value does not effect the frequency of the PWM signal.
 * However it delays the interrupt which occurs every time when the timer reaches the counter period.
 * This disables IT ENA, until the timer reaches the counter period RCR times.
 *
 * Example:
 * Timer1.CNT = 10; Timer1.RCR = 3;
 *
 * Let's start to count:
 * 0 . 1 . 2 ... 8 . 9 -> no IT // RCR-1
 * 0 . 1 . 2 ... 8 . 9 -> no IT // RCR-2
 * 0 . 1 . 2 ... 8 . 9 -> no IT // RCR-3
 * 0 . 1 . 2 ... 8 . 9 -> IT starts
 *
 * STM32 Nucleo F334 Reference Manual: page 694
 *
 * TODO: Kéne egy függvény aminek fordulatszámot adok meg, kiszámolja a freki és prescaler alapján
 *       a helyes RCRValue-t és felülírja
 *
 *
 *
 *	void changeMotorSpeed(StepperMotor *stepperMotors, uint8_t motor_id, uint8_t RCRValue)
 *	{
 *		stepperMotors[motor_id].TIM->Init.RepetitionCounter = RCRValue;
 *		if (HAL_TIM_Base_Init(stepperMotors[motor_id].TIM) != HAL_OK)
 *		{
 *			Error_Handler();
 *		}
 *		return;
 *	}
 */
